/*********************************************************************
 * Copyright (C)
 * File name: 	profile
 * Author: 		Siyuan Sheng
 * Version: 	1
 * Date: 		04/09/2019
 * Description: collect statistics to get the profile of record.bin 
 * 				which is generated by trace_process module.
 * 				The statistics includes the mapping between subset_key
 * 				and index, the mapping between host_key and index, the 
 * 				mapping between app_key and index, and flow records 
 * 				during a time period. 
**********************************************************************/

#ifndef __PROFILE_H__
#define __PROFILE_H__

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <math.h>
#include <map>

#include "../common/util.h"
#include "../common/tuple.h"
#include "../common/ancillary.h"
#include "../common/sparse_counters.h"

#define PROFILE_LOG_PREFIX "[profile] "

// Double type
// Without position info (to support host level):
// 		imc2010 univ1: 0.5s
// 		caida2018: 0.001s
// With position info:
// 		imc2010 univ1 & univ2: 100s
// 		caida2018: 10^5 2.5s, 10^6 50s
// 		maccdc2012: 100s
// 		equinix: 100s
#define TIME_INTERVAL 0.005

class c_subset_key_t {
public:
	uint8_t ip_bytes[4];
	uint32_t prefix_len;
	static const uint32_t serialization_size = 4;

	c_subset_key_t(uint32_t ip, uint32_t prefix_len);
	c_subset_key_t(uint8_t* buf);

	bool operator < (const c_subset_key_t &s) const;
	void serialization(uint8_t* buf) const;
	void to_string(char* buf) const;
};

class c_host_key_t {
public:
	uint32_t ip;
	static const uint32_t serialization_size = sizeof(uint32_t);

	c_host_key_t(uint32_t ip_param);
	c_host_key_t(uint8_t* buf);

	bool operator < (const c_host_key_t &s) const;
	void serialization(uint8_t* buf) const;
	void to_string(char* buf) const;
};

class c_app_key_t {
public:
	uint32_t ip;
	uint16_t port;
	static const uint32_t serialization_size = sizeof(uint32_t)*2;

	c_app_key_t(uint32_t ip_param, uint16_t port_param);
	c_app_key_t(uint8_t* buf);

	bool operator < (const c_app_key_t &s) const;
	void serialization(uint8_t* buf) const;
	void to_string(char* buf) const;
};

class c_flow_key_t {
public:
	flow_key_t key;
	static const uint32_t serialization_size = sizeof(flow_key_t);

	c_flow_key_t(const flow_key_t &key);
	c_flow_key_t(uint8_t* buf);

	bool operator < (const c_flow_key_t &s) const;
	void serialization(uint8_t* buf) const;
	void to_string(char* buf) const;
};

//count flow record involving time intervals during a period
class c_flow_record_t {
private:
	double start_ts;
	uint32_t time_interval_cnt;
	// sparse_counters in record: time -> counter
	std::map<c_flow_key_t, c_sparse_counters_t> record;

	bool has_key(const c_flow_key_t &key) const;

public:
	c_flow_record_t(double start_ts, double end_ts);
	c_flow_record_t(const char* load_file);

	const std::map<c_flow_key_t, c_sparse_counters_t>& get_record() const;
	void update_record(const tuple_t &tuple);
	uint32_t get_number() const;
	uint32_t get_number(uint32_t time_index) const;
	uint32_t get_time_interval_cnt() const;
	void save(const char* save_file) const;
};

#endif
